<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon-large.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/favicon.png?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习,人工智能,英语,HTML,动物," />





  <link rel="alternate" href="/atom.xml" title="纸飞机" type="application/atom+xml" />






<meta name="description" content="雷锋网 AI 研习社按：本文是英特尔数据科学家 Dipanjan Sarkar 在 Medium 上发布的「特征工程」博客续篇。在本系列的前两部分中，作者介绍了连续数据的处理方法和离散数据的处理方法。本文则开始了一个新的主题，非结构化文本数据的传统处理方法。雷锋网 AI 研习社对原文进行了编译。 文本数据通常是由表示单词、句子，或者段落的文本流组成。由于文本数据非结构化（并不是整齐的格式化的数据表">
<meta name="keywords" content="机器学习,人工智能,英语,HTML,动物">
<meta property="og:type" content="article">
<meta property="og:title" content="如何对非结构化文本数据进行特征工程操作？这里有妙招！">
<meta property="og:url" content="http://blockshare.top/2018/c4f43e43/index.html">
<meta property="og:site_name" content="纸飞机">
<meta property="og:description" content="雷锋网 AI 研习社按：本文是英特尔数据科学家 Dipanjan Sarkar 在 Medium 上发布的「特征工程」博客续篇。在本系列的前两部分中，作者介绍了连续数据的处理方法和离散数据的处理方法。本文则开始了一个新的主题，非结构化文本数据的传统处理方法。雷锋网 AI 研习社对原文进行了编译。 文本数据通常是由表示单词、句子，或者段落的文本流组成。由于文本数据非结构化（并不是整齐的格式化的数据表">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p9.pstatp.com/large/61460006eaa4eaed14ee">
<meta property="og:updated_time" content="2018-05-03T14:17:36.275Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何对非结构化文本数据进行特征工程操作？这里有妙招！">
<meta name="twitter:description" content="雷锋网 AI 研习社按：本文是英特尔数据科学家 Dipanjan Sarkar 在 Medium 上发布的「特征工程」博客续篇。在本系列的前两部分中，作者介绍了连续数据的处理方法和离散数据的处理方法。本文则开始了一个新的主题，非结构化文本数据的传统处理方法。雷锋网 AI 研习社对原文进行了编译。 文本数据通常是由表示单词、句子，或者段落的文本流组成。由于文本数据非结构化（并不是整齐的格式化的数据表">
<meta name="twitter:image" content="http://p9.pstatp.com/large/61460006eaa4eaed14ee">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blockshare.top/2018/c4f43e43/"/>





  <title>如何对非结构化文本数据进行特征工程操作？这里有妙招！ | 纸飞机</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?11e1fcf8c087695ab66673652234e853";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">纸飞机</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">您的云收藏知识库！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blockshare.top/2018/c4f43e43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhifeiji">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="纸飞机">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">如何对非结构化文本数据进行特征工程操作？这里有妙招！</h1>
        

        <div class="post-meta">
          <span class="post-time">

            
                <span class="post-meta-item-text">雷锋网</span>
            

            
              <span class="post-meta-divider">|</span>
            
          </span>

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T09:33:21+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/c4f43e43/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/c4f43e43/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i></span>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://p9.pstatp.com/large/61460006eaa4eaed14ee" rel="gallery_cjjyjuhn500j4wrqd4javrlzs"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://p9.pstatp.com/large/61460006eaa4eaed14ee" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <p>雷锋网 AI 研习社按：本文是英特尔数据科学家 Dipanjan Sarkar 在 Medium 上发布的「特征工程」博客续篇。在本系列的前两部分中，作者介绍了连续数据的处理方法和离散数据的处理方法。本文则开始了一个新的主题，<strong>非结构化文本数据的传统处理方法</strong>。雷锋网 AI 研习社对原文进行了编译。</p>
<p>文本数据通常是由表示单词、句子，或者段落的文本流组成。由于文本数据非结构化（并不是整齐的格式化的数据表格）的特征和充满噪声的本质，很难直接将机器学习方法应用在原始文本数据中。在本文中，我们将通过实践的方法，探索从文本数据提取出有意义的特征的一些普遍且有效的策略，提取出的特征极易用来构建机器学习或深度学习模型。</p>
<h2 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h2><p>想要构建性能优良的机器学习模型，特征工程必不可少。有时候，可能只需要一个优秀的特征，你就能赢得 Kaggle 挑战赛的胜利！对于非结构化的文本数据来说，特征工程更加重要，因为我们需要将文本流转化为机器学习算法能理解的数字表示。即使现在有高级的自动化特征工程，在把它们当作「黑盒子」应用之前，我们仍有必要去了解不同特征工程策略背后的核心思想。永远记住，「如果有人给了你一套修房子的工具，你应该知道什么时候该用电钻，什么时候该用锤子！」</p>
<h2 id="理解文本数据"><a href="#理解文本数据" class="headerlink" title="理解文本数据"></a>理解文本数据</h2><p>我们虽然能够获得具有结构数据属性的文本数据，但它们为结构化数据，并不在今天的讨论范围之内。</p>
<p>在本文中，我们讨论以单词、短语、句子和整个文档的形式展现的文本流。从本质上讲，文本确实有一些句法结构，比如单词组成了短语，短语组成了句子，句子又组合成了段落。然而，与结构化数据集中固定的数据维度相比，文本文档没有固定的结构，因为单词有众多的选择，每个句子的长度也是可变的。本文就是一个很典型的案例。</p>
<h2 id="特征工程的策略"><a href="#特征工程的策略" class="headerlink" title="特征工程的策略"></a>特征工程的策略</h2><p>下面是一些流行且有效的处理文本数据的策略，这些方法也能应用在下游的机器学习系统中，用于提取有用的特征。大家可以在 GitHub中查看本文使用的所有代码。</p>
<p>首先加载一些基本的依赖关系和设置：</p>
<blockquote>
<p>import pandas as pdimport numpy as npimport reimport nltkimport matplotlib.pyplot as pltpd.options.display.max_colwidth = 200%matplotlib inline</p>
</blockquote>
<p>下面是文档中的语料库，本文大部分内容都是基于该数据集的分析。语料库通常是属于一个或多个主题的文档的集合。</p>
<blockquote>
<p>corpus = &#91;’The sky is blue and beautiful.’, ‘Love this blue and beautiful sky!’, ‘The quick brown fox jumps over the lazy dog.’, “A king’s breakfast has sausages, ham, bacon, eggs, toast and beans”, ‘I love green eggs, ham, sausages and bacon!’, ‘The brown fox is quick and the blue dog is lazy!’, ‘The sky is very blue and the sky is very beautiful today’, ‘The dog is lazy but the brown fox is quick!’ &#93; labels = &#91;’weather’, ‘weather’, ‘animals’, ‘food’, ‘food’, ‘animals’, ‘weather’, ‘animals’&#93; <br><br>corpus = np.array(corpus) corpus_df = pd.DataFrame(&amp;#123’Document’&#58; corpus, ‘Category’&#58; labels&amp;#125) corpus_df = corpus_df&#91;&#91;’Document’, ‘Category’&#93;&#93; corpus_df </p>
</blockquote>
<p>本文中应用的语料库案例 </p>
<p>可以看到，我们已经从语料库中提取出几个不同类别的文档。在讨论特征工程之前，一如往常，首先得做数据预处理，删除一些不必要的字符、符号和标记。</p>
<h2 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h2><p>有很多种对文本数据进行清洗和预处理的方法。下面我将重点介绍在自然语言处理（NLP）流程中大量使用的方法。</p>
<ul>
<li>删除标签：文本中通常会包含一些不必要的内容，比如 HTML 标签，这在分析文本时并没有太多价值。BeautifulSoup 库提供了清理标签的函数。- 清理重音字符：在许多文本语料库中，特别是在处理英文时，通常会遇到重音字符/字母。因此我们要确保将这些字符转换为标准的 ASCII 字符。一个简单的例子就是将 é 转换成 e。- 拓展缩写：在英文中，缩写基本上是单词或者音节的缩减版。缩减版通常是删除某些单词或者短语中特定的字母和声音而来。举例来说，do not 和 don’t , I would 和 I’d。将缩写单词转换为完整的原始形式有助于文本的标准化。- 删除特殊字符：特殊字符和非字母数字的符号通常会增加额外噪声。通常，可以通过简单的正则表达式来实现这一点。- 词干提取和词性还原：可以利用词干创造新的词汇，例如通过附加前缀和后缀等词缀来创造新的单词。这被称为词性变化。词干提取是将这个过程反过来。一个简单的例子是单词：WATCHES, WATCHING, 和 WATCHED，这些单词都把 WATCH 作为词根。词性还原与词干提取很相似，通过移除词缀以得到单词的基本形式。然而在词性还原里，单词的基本形式是词根（root word），而不是词干（root stem）。其不同之处在于词根（root word）总是字典上正确的词（即出现在词典中），但词干并不是这样。- 去除无用词：在从文本中构建有意义的特征时，没有意义的词被称为无用词。如果你在一个语料库中做一个简单的词频分析，这些无用词通常会以最大的频率出现。像 a , an 这样的词被认为是无用词。但是实际上并没有明确通用的无用词表，我们通常使用 nltk 的标准英语无用词表。大家也可以根据特定的需要添加无用词。<br>清理重音字符：在许多文本语料库中，特别是在处理英文时，通常会遇到重音字符/字母。因此我们要确保将这些字符转换为标准的 ASCII 字符。一个简单的例子就是将 é 转换成 e。</li>
</ul>
<p>删除特殊字符：特殊字符和非字母数字的符号通常会增加额外噪声。通常，可以通过简单的正则表达式来实现这一点。</p>
<p>去除无用词：在从文本中构建有意义的特征时，没有意义的词被称为无用词。如果你在一个语料库中做一个简单的词频分析，这些无用词通常会以最大的频率出现。像 a , an 这样的词被认为是无用词。但是实际上并没有明确通用的无用词表，我们通常使用 nltk 的标准英语无用词表。大家也可以根据特定的需要添加无用词。</p>
<p>除此之外，还可以使用其他的标准操作，比如标记化、删除多余的空格、文本大写转换为小写，以及其他更高级的操作，例如拼写更正、语法错误更正、删除重复字符等。</p>
<p>由于本文的重点是特征工程，我们将构建一个简单的文本预处理程序，其重点是删除特殊字符、多余的空格、数字、无用词以及语料库的大写转小写。</p>
<blockquote>
<p>wpt = nltk.WordPunctTokenizer stop_words = nltk.corpus.stopwords.words(‘english’) <br>def normalize_document(doc)&#58; # lower case and remove special characters\whitespaces doc = re.sub(r’&#91;^a-zA-Z\s&#93;’, ‘’, doc, re.I|re.A) doc = doc.lower doc = doc.strip # tokenize document tokens = wpt.tokenize(doc) # filter stopwords out of document filtered_tokens = &#91;token for token in tokens if token not in stop_words&#93; # re-create document from filtered tokens doc = ‘ ‘.join(filtered_tokens) return doc <br>normalize_corpus = np.vectorize(normalize_document) </p>
</blockquote>
<p>一旦搭建好基础的预处理流程，我们就可以将它应用在语料库中了。</p>
<blockquote>
<p>norm_corpus = normalize_corpus(corpus)norm_corpus<br>Output——array(&#91;’sky blue beautiful’, ‘love blue beautiful sky’,’quick brown fox jumps lazy dog’,’kings breakfast sausages ham bacon eggs toast beans’,’love green eggs ham sausages bacon’,’brown fox quick blue dog lazy’, ‘sky blue sky beautiful today’,’dog lazy brown fox quick’&#93;,dtype=’</p>
</blockquote>
<p>上面的输出结果应该能让大家清楚的了解样本文档在预处理之后的样子。现在我们来开始特征工程吧!</p>
<h2 id="词袋模型（Bag-of-Word）"><a href="#词袋模型（Bag-of-Word）" class="headerlink" title="词袋模型（Bag of Word）"></a>词袋模型（Bag of Word）</h2><p>这也许是非结构化文本中最简单的向量空间表示模型。向量空间是表示非结构化文本（或其他任何数据）的一种简单数学模型，向量的每个维度都是特定的特征/属性。词袋模型将每个文本文档表示为数值向量，其中维度是来自语料库的一个特定的词，而该维度的值可以用来表示这个词在文档中的出现频率、是否出现（由 0 和 1 表示），或者加权值。将这个模型叫做词袋模型，是因为每个文档可以看作是装着单词的袋子，而无须考虑单词的顺序和语法。</p>
<blockquote>
<p>from sklearn.feature_extraction.text import CountVectorizer <br>cv = CountVectorizer(min_df=0., max_df=1.) cv_matrix = cv.fit_transform(norm_corpus) cv_matrix = cv_matrix.toarray cv_matrix </p>
</blockquote>
<p>可以看到，文档已经被转换为数字向量，这样每个文档都由上述特征矩阵中的一个向量（行）表示。下面的代码有助于以一种更易理解的格式来表示这一点。</p>
<blockquote>
<h1 id="get-all-unique-words-in-the-corpus-vocab-cv-get-feature-names-show-document-feature-vectors-pd-DataFrame-cv-matrix-columns-vocab"><a href="#get-all-unique-words-in-the-corpus-vocab-cv-get-feature-names-show-document-feature-vectors-pd-DataFrame-cv-matrix-columns-vocab" class="headerlink" title="get all unique words in the corpus vocab = cv.get_feature_names # show document feature vectors pd.DataFrame(cv_matrix, columns=vocab)"></a>get all unique words in the corpus vocab = cv.get_feature_names # show document feature vectors pd.DataFrame(cv_matrix, columns=vocab)</h1></blockquote>
<p>词袋模型的文档特征向量</p>
<p>上面的表格应该更能助于理解！可以清楚地看到，特征向量中每个列（维度）都代表一个来自语料库的单词，每一行代表一个文档。单元格中的值表示单词（由列表示）出现在特定文档（由行表示）中的次数。因此，如果一个文档语料库是由 N 个单词组成，那么这个文档可以由一个 <strong>N 维向量</strong>表示。</p>
<h2 id="N-元词袋模型（Bag-of-N-Gram-Model）"><a href="#N-元词袋模型（Bag-of-N-Gram-Model）" class="headerlink" title="N 元词袋模型（Bag of N-Gram Model）"></a>N 元词袋模型（Bag of N-Gram Model）</h2><p>一个单词只是一个标记，通常被称为单元（unigram）或者一元（1-gram）。我们已经知道，词袋模型不考虑单词的顺序。但是如果我们也想要考虑序列中出现的短语或者词汇集合呢？N 元模型能够帮我们实现这一点。N-Gram 是来自文本文档的单词记号的集合，这些记号是连续的，并以序列的形式出现。二元表示阶数为二的 N-Gram，也就是两个单词。同理三元表示三个单词。N 元词袋模型是普通词袋模型的一种拓展，使得我们可以利用基于 N 元的特征。下面的示例展示了文档中二元的特征向量。</p>
<blockquote>
<h1 id="you-can-set-the-n-gram-range-to-1-2-to-get-unigrams-as-well-as-bigrams-bv-CountVectorizer-ngram-range-2-2-bv-matrix-bv-fit-transform-norm-corpus-bv-matrix-bv-matrix-toarray-vocab-bv-get-feature-names-pd-DataFrame-bv-matrix-columns-vocab"><a href="#you-can-set-the-n-gram-range-to-1-2-to-get-unigrams-as-well-as-bigrams-bv-CountVectorizer-ngram-range-2-2-bv-matrix-bv-fit-transform-norm-corpus-bv-matrix-bv-matrix-toarray-vocab-bv-get-feature-names-pd-DataFrame-bv-matrix-columns-vocab" class="headerlink" title="you can set the n-gram range to 1,2 to get unigrams as well as bigrams bv = CountVectorizer(ngram_range=(2,2)) bv_matrix = bv.fit_transform(norm_corpus) bv_matrix = bv_matrix.toarray vocab = bv.get_feature_names pd.DataFrame(bv_matrix, columns=vocab)"></a>you can set the n-gram range to 1,2 to get unigrams as well as bigrams bv = CountVectorizer(ngram_range=(2,2)) bv_matrix = bv.fit_transform(norm_corpus) bv_matrix = bv_matrix.toarray vocab = bv.get_feature_names pd.DataFrame(bv_matrix, columns=vocab)</h1></blockquote>
<p>使用二元词袋模型的特征向量</p>
<p>在上面的例子中，每个二元特征由两个单词组成，其中的值表示这个二元词组在文档中出现的次数。</p>
<h2 id="TF-IDF-模型"><a href="#TF-IDF-模型" class="headerlink" title="TF-IDF 模型"></a>TF-IDF 模型</h2><p>在大型语料库中使用词袋模型可能会出现一些潜在的问题。由于特征向量是基于词的频率，某些单词可能会在文档中频繁出现，这可能会在特征集上掩盖掉其他单词。TF-IDF 模型试图通过缩放或者在计算中使用归一化因子来解决这个问题。TF-IDF 即 Term Frequency-Inverse Document Frequency，在计算中结合了两种度量：<strong>词频（Term Frequency）</strong>和<strong>逆文档频率（Inverse Document Frequency）</strong>。这种技术是为搜索引擎中查询排序而开发的，现在它是信息检索和 NLP 领域中不可或缺的模型。</p>
<p>在数学上，TF-IDF 可以定义为：<strong>tfidf = tf x idf</strong>，也可以进一步拓展为下面的表示：</p>
<p>在这里，<strong>tfidf（w, D）</strong>表示单词<strong>w </strong>在文档<strong>D </strong>中的 TF-IDF 分数。<strong>Tf（w,D）</strong>项表示单词<strong>w </strong>在文档<strong>D </strong>中的词频，这个值可以从词袋模型中获得。<strong>idf（w，D）</strong>项是单词<strong>w </strong>的逆文档频率，可以由语料库中所有文档的总数量<strong>C </strong>除以单词<strong>w </strong>的文档频率<strong>df（w）</strong>的 log 值得到，其中文档频率是指语料库中文档出现单词<strong>w </strong>的频率。这种模型有多种变种，但是给出的最终结果都很相似。下面在语料库中使用这个模型吧！</p>
<blockquote>
<p>from sklearn.feature_extraction.text import TfidfVectorizer <br>tv = TfidfVectorizer(min_df=0., max_df=1., use_idf=True) tv_matrix = tv.fit_transform(norm_corpus) tv_matrix = tv_matrix.toarray <br>vocab = tv.get_feature_names pd.DataFrame(np.round(tv_matrix, 2), columns=vocab) </p>
</blockquote>
<p>基于TF-IDF模型的文档特征向量</p>
<p>基于 TF-IDF 的特征向量与原始的词袋模型相比，展示出了缩放和归一化的特性。想要进一步深入了解该模型的读者可以参考 Text Analytics with Python的 181 页。</p>
<h2 id="文档相似性"><a href="#文档相似性" class="headerlink" title="文档相似性"></a>文档相似性</h2><p>文档相似性是使用从词袋模型或者 tf-idf 模型中提取出的特征，基于距离或者相似度度量判断两个文档相似程度的过程。</p>
<p>因此，可以使用在上一部分中提到的 tf-idf 模型提取出的特征，用其来生成新的特征。这些特征在搜索引擎、文档聚类以及信息检索等领域发挥着重要作用。</p>
<p>语料库中的配对文档相似性需要计算语料库中每两个文档对的文档相似性。因此，如果一个语料库中有 C 个文档，那么最终会得到一个 C*C 的矩阵，矩阵中每个值代表了该行和该列的文档对的相似度分数。可以用几种相似度和距离度量计算文档相似度。其中包括余弦距离/相似度、欧式距离、曼哈顿距离、BM25相似度、jaccard 距离等。在我们的分析中，我们将使用最流行和最广泛使用的相似度度量：余弦相似度，并根据 TF-IDF 特征向量比较文档对的相似度。</p>
<blockquote>
<p>from sklearn.metrics.pairwise import cosine_similarity <br>similarity_matrix = cosine_similarity(tv_matrix) similarity_df = pd.DataFrame(similarity_matrix) similarity_df </p>
</blockquote>
<p>文档对的相似性矩阵(余弦相似度)</p>
<p>余弦相似度给出了表示两个文档特征向量之间角度的余弦值的度量。两个文档特征向量之间的角度越低，两个文档的相似度就越高，如下图所示：</p>
<p>仔细观察相似度矩阵可以清楚地看出，文档（0，1 和 6），（2，5 和 7）之间非常相似，文档 3 和 4 略微相似。这表明了这些相似的文档一定具有一些相似特征。这是分组或聚类的一个很好的案例，可以通过无监督的学习方法来解决，特别是当需要处理数百万文本文档的庞大语料库时。</p>
<h2 id="具有相似特征的文档聚类"><a href="#具有相似特征的文档聚类" class="headerlink" title="具有相似特征的文档聚类"></a>具有相似特征的文档聚类</h2><p>聚类是利用无监督学习的方法，将数据点(本场景中即文档)分类到组或者 cluster 中。我们将在这里利用一个无监督的层次聚类算法，通过利用我们之前生成的文档相似性特征，将我们的玩具语料库中的类似文档聚合到一起。有两种类型的层次聚类方法，分别是凝聚方法（agglomerative）和分裂方法（divisive）。这里将会使用凝聚聚类算法，这是一种自下而上（bottom up）的层次聚类算法，最开始每个文档的单词都在自己的类中，根据测量数据点之间的距离度量和连接准则（linkage criterion），将相似的类连续地合并在一起。下图展示了一个简单的描述。</p>
<p>连接准则决定了合并策略。常用的连接准则有 Ward, Complete linkage, Average linkage 等等。这些标准在将一对 cluster 合并在一起（文档中低层次的类聚类成高层次的）时是非常有用的，这是通过最优化目标函数实现的。我们选择 Ward 最小方差作为连接准则，以最小化总的内部聚类方差。由于已经有了相似特征，我们可以直接在样本文档上构建连接矩阵。</p>
<blockquote>
<p>from scipy.cluster.hierarchy import dendrogram, linkage <br>Z = linkage(similarity_matrix, ‘ward’) pd.DataFrame(Z, columns=&#91;’Document\Cluster 1’, ‘Document\Cluster 2’, ‘Distance’, ‘Cluster Size’&#93;, dtype=’object’) </p>
</blockquote>
<p>我们语料库的连接矩阵</p>
<p>如果仔细查看连接矩阵，可以看到连接矩阵的每个步骤（行）都告诉了我们哪些数据点（或者 cluster）被合并在一起。如果有 n 个数据点，那么连接矩阵 Z 将是（n-1）*4 的形状，其中 Z&#91;i&#93; 表示在步骤 i 合并了哪些 cluster。每行有四个元素，前两个元素是数据点或 cluster 的名称，第三个元素是前两个元素（数据点或 cluster）之间的距离，最后一个元素是合并完成后 cluster 中元素/数据点的总数。大家可以参考 scipy 文档，其中有详细解释。</p>
<p>下面，把这个矩阵看作一个树状图，以更好地理解元素！</p>
<blockquote>
<p>plt.figure(figsize=(8, 3)) plt.title(‘Hierarchical Clustering Dendrogram’) plt.xlabel(‘Data point’) plt.ylabel(‘Distance’) dendrogram(Z) plt.axhline(y=1.0, c=’k’, ls=’–’, lw=0.5) </p>
</blockquote>
<p>可以看到每个数据点是如何从一个单独的簇开始，慢慢与其他数据点合并形成集群的。从颜色和树状图的更高层次来看，如果考虑距离度量为 1.0（由虚线表示）或者更小，可以看出模型已经正确识别了三个主要的聚类。利用这个距离，我们可以得到集群的标签。</p>
<blockquote>
<p>from scipy.cluster.hierarchy import fcluster max_dist = 1.0 <br>cluster_labels = fcluster(Z, max_dist, criterion=’distance’) cluster_labels = pd.DataFrame(cluster_labels, columns=&#91;’ClusterLabel’&#93;) pd.concat(&#91;corpus_df, cluster_labels&#93;, axis=1) </p>
</blockquote>
<p>可以清楚地看到，我们的算法已经根据分配给它们的标签，正确识别了文档中的三个不同类别。这应该能够给大家一个关于如何使用 TF-IDF 特征来建立相似度特征的思路。大家可以用这种处理流程来进行聚类。</p>
<h2 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h2><p>也可以使用一些摘要技术从文本文档中提取主题或者基于概念的特征。主题模型围绕提取关键主题或者概念。每个主题可以表示为文档语料库中的一个词袋或者一组词。总之，这些术语表示特定的话题、主题或概念，凭借这些单词所表达的语义含义，可以轻松将每个主题与其他主题区分开来。这些概念可以从简单的事实、陈述到意见、前景。主题模型在总结大量文本来提取和描绘关键概念时非常有用。它们也可用于从文本数据中捕捉潜在的特征。</p>
<p>主题建模有很多种方法，其中大多涉及到某种形式的矩阵分解。比如隐含语义索引（Latent Semantic Indexing， LSI）就使用了奇异值分解。这里将使用另一种技术：隐含狄利克雷分布（Latent Dirichlet Allocation， LDA），它使用了生成概率模型，其中每个文档由几个主题组合而成，每个术语或单词可以分配给某个主题。这与基于 pLSI（probabilistic LSI）的模型很类似。在 LDA 的情况下，每个隐含主题都包含一个狄利克雷先验。</p>
<p>这项技术背后的数学原理相当复杂，所以我会试着总结一下，而不是罗列很多让人厌倦的细节。我建议读者可以看看 Christine Doig 的一个优秀的演讲，深入了解一下。</p>
<p>上图中的黑色框表示利用前面提到的参数，从 M 个文档中提取 K 个主题的核心算法。下面的步骤是对算法的解释。</p>
<ol>
<li>初始化必要的参数。1. 随机初始化文档，将每个单词分配到 K 个主题中去。1. 按照如下方法迭代1. 对于每个文档 D：<br>随机初始化文档，将每个单词分配到 K 个主题中去。</li>
</ol>
<p>对于每个文档 D：</p>
<p>a) 对于文档中的单词 W：</p>
<p>i.对于主题 T：</p>
<p>计算 P(T|D)， 表示文档 D 中单词分配给 T 主题的比例。</p>
<p>计算 P(W|T)，表示在所有文档中，主题 T 包含单词 W 的比例。</p>
<p>ii. 通过计算概率 P(T|D)*P(W|T) 重新分配单词 W 的主题 T。</p>
<p>运行几个迭代之后，就能获得混合了每个文档的主题，然后就可以根据指向某个主题的单词生成文档的主题。像 gensim 或者 scikit-learn 这样的框架，使得我们能够利用 LDA 模型来生成主题。</p>
<p>大家应该记住，当 LDA 应用于文档-单词矩阵（TF-IDF 或者词袋特征矩阵）时，它会被分解为两个主要部分：</p>
<ul>
<li>文档-主题矩阵，也就是我们要找的特征矩阵- 主题-单词矩阵，能够帮助我们查看语料库中潜在的主题<br>主题-单词矩阵，能够帮助我们查看语料库中潜在的主题</li>
</ul>
<p>使用 scikit-learn 可以得到如下的文档-主题矩阵。</p>
<blockquote>
<p>from sklearn.decomposition import LatentDirichletAllocation <br>lda = LatentDirichletAllocation(n_topics=3, max_iter=10000, random_state=0) dt_matrix = lda.fit_transform(cv_matrix) features = pd.DataFrame(dt_matrix, columns=&#91;’T1’, ‘T2’, ‘T3’&#93;) features </p>
</blockquote>
<p>可以清楚地看到哪些文档对上述输出中的三个主题贡献最大，可以通过如下的方式查看主题及其组成部分。</p>
<blockquote>
<p>tt_matrix = lda.components_ for topic_weights in tt_matrix&#58; topic = &#91;(token, weight) for token, weight in zip(vocab, topic_weights)&#93; topic = sorted(topic, key=lambda x&#58; -x&#91;1&#93;) topic = &#91;item for item in topic if item&#91;1&#93; &gt; 0.6&#93; print(topic) print </p>
</blockquote>
<p>可以看到，由于组成术语不同，很容易区分这三个主题。第一个在讨论天气，第二个关于食物，最后一个关于动物。主题建模的主题数量选择是一门完整的课题，既是一门艺术，也是一门科学。获得最优主题数量的方法有很多，这些技术既复杂又繁琐，这里就不展开讨论了。</p>
<h2 id="使用主题模型特征的文档聚类"><a href="#使用主题模型特征的文档聚类" class="headerlink" title="使用主题模型特征的文档聚类"></a>使用主题模型特征的文档聚类</h2><p>这里使用 LDA 法从词袋模型特征构建主题模型特征。现在，我们可以利用获得的文档单词矩阵，使用无监督的聚类算法，对文档进行聚类，这与我们之前使用的相似度特征进行聚类类似。</p>
<p>这次我们使用非常流行的基于分区的聚类方法——K-means 聚类，根据文档主题模型特征表示，进行聚类或分组。在 K-means 聚类法中，有一个输入参数 K，它制定了使用文档特征输出的聚类数量。这种聚类方法是一种基于中心的聚类方法，试图将这些文档聚类为等方差的类。这种方法通过最小化类内平方和来创建聚类。选择出最优的 K 的方法有很多，比如误差平方和度量，轮廓系数（Silhouette Coefficients）和 Elbow method。</p>
<blockquote>
<p>from sklearn.cluster import KMeans km = KMeans(n_clusters=3, random_state=0) km.fit_transform(features) cluster_labels = km.labels_ cluster_labels = pd.DataFrame(cluster_labels, columns=&#91;’ClusterLabel’&#93;) pd.concat(&#91;corpus_df, cluster_labels&#93;, axis=1) </p>
</blockquote>
<p>从上面的输出中可以看到，文档的聚类分配完全正确。</p>
<h2 id="未来会涉及到的高级策略"><a href="#未来会涉及到的高级策略" class="headerlink" title="未来会涉及到的高级策略"></a>未来会涉及到的高级策略</h2><p>在这篇文章没有涉及近期出现的一些关于文本数据特征工程的高级方法，包括利用深度学习模型来提取单词特征的方法。我们将在本系列的下一部分中深入探讨这些模型，并详细介绍 Word2Vec和GloVe等流行的单词嵌入模型，敬请期待!</p>
<p><strong>总结</strong></p>
<p>这些例子应该能有助于大家理解文本数据特征工程的一些通用策略。本文中介绍的是基于数学概念、信息检索和自然语言处理的传统策略，这些久经考验的方法在各种数据集和问题上都表现优异。在下一篇文章中，我将详细介绍如何利用深度学习模型进行文本数据特征工程。</p>
<p>对连续数据特征工程感兴趣的读者，请查看本系列第一部分！</p>
<p>对离散数据特征工程感兴趣的读者，请查看本系列第二部分！</p>
<p>本文中所使用的所有代码和数据集都可以从 GitHub中访问。代码也可以作为Jupyter笔记本使用。</p>
<p>Via towardsdatascience.com雷锋网 AI 研习社编译整理。</p>
<blockquote>
<p><strong>转载来源</strong>：<a href="https://www.toutiao.com/a6519698941288645124/" target="_blank" rel="noopener">如何对非结构化文本数据进行特征工程操作？这里有妙招！</a></p>
</blockquote>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>让纸飞机飞得更快更高：</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>点赞</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.png" alt="zhifeiji 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/alipay.jpg" alt="zhifeiji 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/人工智能/" rel="tag"># 人工智能</a>
          
            <a href="/tags/英语/" rel="tag"># 英语</a>
          
            <a href="/tags/HTML/" rel="tag"># HTML</a>
          
            <a href="/tags/动物/" rel="tag"># 动物</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/895b955b/" rel="next" title="知识｜从Github上看深度学习和自然语言处理有趣的项目">
                <i class="fa fa-chevron-left"></i> 知识｜从Github上看深度学习和自然语言处理有趣的项目
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/0f00756f/" rel="prev" title="IPFS+IPNS+个人博客搭建 - 简书">
                IPFS+IPNS+个人博客搭建 - 简书 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar1.jpg"
                alt="zhifeiji" />
            
              <p class="site-author-name" itemprop="name">zhifeiji</p>
              <p class="site-description motion-element" itemprop="description">纸飞机，您可以随时随地分享链接、图片、文字、视频等，轻轻一掷，我们会帮您做整理、归类，创建属于您的个人空间。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">342</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">380</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:zymlpear@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#研究动机"><span class="nav-number">1.</span> <span class="nav-text">研究动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解文本数据"><span class="nav-number">2.</span> <span class="nav-text">理解文本数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征工程的策略"><span class="nav-number">3.</span> <span class="nav-text">特征工程的策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本预处理"><span class="nav-number">4.</span> <span class="nav-text">文本预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#词袋模型（Bag-of-Word）"><span class="nav-number">5.</span> <span class="nav-text">词袋模型（Bag of Word）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#get-all-unique-words-in-the-corpus-vocab-cv-get-feature-names-show-document-feature-vectors-pd-DataFrame-cv-matrix-columns-vocab"><span class="nav-number"></span> <span class="nav-text">get all unique words in the corpus vocab = cv.get_feature_names # show document feature vectors pd.DataFrame(cv_matrix, columns=vocab)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#N-元词袋模型（Bag-of-N-Gram-Model）"><span class="nav-number">1.</span> <span class="nav-text">N 元词袋模型（Bag of N-Gram Model）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#you-can-set-the-n-gram-range-to-1-2-to-get-unigrams-as-well-as-bigrams-bv-CountVectorizer-ngram-range-2-2-bv-matrix-bv-fit-transform-norm-corpus-bv-matrix-bv-matrix-toarray-vocab-bv-get-feature-names-pd-DataFrame-bv-matrix-columns-vocab"><span class="nav-number"></span> <span class="nav-text">you can set the n-gram range to 1,2 to get unigrams as well as bigrams bv = CountVectorizer(ngram_range=(2,2)) bv_matrix = bv.fit_transform(norm_corpus) bv_matrix = bv_matrix.toarray vocab = bv.get_feature_names pd.DataFrame(bv_matrix, columns=vocab)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TF-IDF-模型"><span class="nav-number">1.</span> <span class="nav-text">TF-IDF 模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档相似性"><span class="nav-number">2.</span> <span class="nav-text">文档相似性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具有相似特征的文档聚类"><span class="nav-number">3.</span> <span class="nav-text">具有相似特征的文档聚类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主题模型"><span class="nav-number">4.</span> <span class="nav-text">主题模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用主题模型特征的文档聚类"><span class="nav-number">5.</span> <span class="nav-text">使用主题模型特征的文档聚类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未来会涉及到的高级策略"><span class="nav-number">6.</span> <span class="nav-text">未来会涉及到的高级策略</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">纸飞机</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytz1Qb4z';
      var conf = '058029b4a38c8366d2fd43c54318cba0';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
